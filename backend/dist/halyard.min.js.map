{"version":3,"file":"halyard.min.js","sources":["../src/utils/utils.js","../src/connections/connection-base.js","../src/connections.js","../src/connections/file.js","../src/connections/web-file.js","../src/connections/inline-data.js","../src/utils/json-to-csv.js","../src/default-connection-matcher.js","../src/connection-matcher.js","../src/utils/format-specification.js","../src/table.js","../src/utils/hyper-cube-specification.js","../src/utils/hyper-cube-utils.js","../src/hyper-cube.js","../src/set-statement.js","../src/derived-fields-template.js","../src/calendar-derived-fields.js","../src/halyard.js"],"sourcesContent":["/**\n * Get folder path from file path\n * @private\n * @param {string} path\n * @returns {string}\n */\nexport function folderPath(path) {\n  let folderPathMatch = path.match(/^(.*)(\\\\.*\\..*$|\\\\.*)$/);\n\n  if (folderPathMatch) {\n    return folderPathMatch[1];\n  }\n\n  // Unix file path check\n  folderPathMatch = path.match(/^(.*)(\\/.*\\..*$|\\/.*)$/);\n\n  return folderPathMatch && folderPathMatch[1];\n}\n\n/**\n * Get file name from file path\n * @private\n * @param {string} path\n * @returns {string}\n */\nexport function fileName(path) {\n  let fileNameMatch = path.match(/^.*\\\\(.*\\..*|.*)$/);\n\n  if (fileNameMatch) {\n    return fileNameMatch[1];\n  }\n\n  fileNameMatch = path.match(/^.*\\/(.*\\..*|.*)$/);\n\n  return fileNameMatch && fileNameMatch[1];\n}\n\n/**\n * Get file extension from file path\n * @private\n * @param {string} path\n * @returns {string}\n */\nexport function fileExtension(path) {\n  const fileExtensionMatch = path.match(/^.*\\.(.*)$/);\n\n  return fileExtensionMatch && fileExtensionMatch[1];\n}\n\n/**\n * Escape text with double quotes\n * @private\n * @param {string} text\n * @returns {string}\n */\nexport function escapeText(text) {\n  return text.replace(/\"/g, '\"\"');\n}\n\n/**\n * Get a unique name\n * @private\n * @returns {string}\n */\nexport function uniqueName() {\n  /* eslint no-bitwise: [\"off\"] */\n  /* eslint no-mixed-operators: [\"off\"] */\n\n  return 'xxxxx-8xxxx-yxxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/**\n * Validate the field type\n * @private\n * @param {string} type\n * @returns {boolean}\n */\nexport function validFieldType(type) {\n  const validFieldTypes = ['time', 'timestamp', 'date', 'interval'];\n\n  type = type || '';\n\n  return validFieldTypes.indexOf(type.toLowerCase()) > -1;\n}\n\n/**\n * Get indentation characters\n * @private\n * @returns {string}\n */\nexport function indentation() {\n  return '  ';\n}\n\n/**\n * Get the field name\n * @private\n * @param {Field} field\n * @returns {string}\n */\nexport function getFieldName(field) {\n  return field.name || field.src;\n}\n","import { uniqueName } from '../utils/utils';\n\n/**\n * A base set of methods used by Connections\n * @typedef {object} Connection\n * @property {string} path - The Path to a resource\n * @property {string} connectionType - The type can be either 'folder' or 'internet'\n */\n\nclass ConnectionBase {\n  /**\n   * A base set of methods used by Connections\n   * @public\n   * @param {string} path - The Path to a resource\n   * @param {string} connectionType - The type can be either 'folder' or 'internet'\n   * @class\n   */\n  constructor(path, connectionType) {\n    this.path = path;\n    this.connectionType = connectionType;\n    this.fileExtension = '';\n  }\n\n  /**\n   * Returns specified file extension.\n   * @public\n   * @returns {string}\n   */\n  getFileExtension() {\n    return this.fileExtension;\n  }\n\n  /**\n   * Get specified connection type.\n   * @public\n   * @returns {string}\n   */\n  getConnectionType() {\n    return this.connectionType;\n  }\n\n  /**\n   * Get the QIX representation of a connection.\n   * @public\n   * @returns {{qName: (string), qConnectionString: (string), qType: (string)}}\n   */\n  getQixConnectionObject() {\n    return {\n      qName: this.getName(),\n      qConnectionString: this.path,\n      qType: this.getConnectionType(),\n    };\n  }\n\n  /**\n   * Get the name and if nothing is set then it will receive a unique name\n   * @public\n   * @returns {string}\n   */\n  getName() {\n    if (!this.name) {\n      this.name = uniqueName();\n    }\n\n    return this.name;\n  }\n\n  /**\n   * Get the lib statement used in the load script to connect to a connection\n   * @public\n   * @returns {string}\n   */\n  getLibStatement() {\n    return `lib://${this.getName()}`;\n  }\n\n  /**\n   * Get the load script for this connection\n   * @public\n   * @returns {string}\n   */\n  getScript() {\n    return `FROM [${this.getLibStatement()}]`;\n  }\n}\n\nexport default ConnectionBase;\n","import FileConnection from './connections/file';\nimport WebConnection from './connections/web-file';\nimport InlineData from './connections/inline-data';\n\n/**\n * Default set of Connections that are available\n * @constant\n * @type {object}\n */\nexport default {\n  File: FileConnection,\n  Web: WebConnection,\n  Inline: InlineData,\n};\n","import ConnectionBase from './connection-base';\nimport * as Utils from '../utils/utils';\n\nclass FileConnection extends ConnectionBase {\n  /**\n   * File Connection representation. It will create a folder connection in QIX.\n   * @public\n   * @param {string} path - Absolute file path\n   * @constructor\n   */\n  constructor(path) {\n    super(Utils.folderPath(path), 'folder');\n\n    this.fileName = Utils.fileName(path);\n\n    this.fileExtension = Utils.fileExtension(path) || 'txt';\n  }\n\n  /**\n   * Get the lib statement for the specified file path\n   * @public\n   * @returns {string}\n   */\n  getLibStatement() {\n    return `${super.getLibStatement()}/${this.fileName}`;\n  }\n}\n\nexport default FileConnection;\n","import ConnectionBase from './connection-base';\n\nclass WebFileConnection extends ConnectionBase {\n  /**\n   * Web file connector structure. It will setup everything to create a QIX internet connection.\n   * @public\n   * @param {string} url\n   * @param {string} fileExtension\n   */\n  constructor(url, fileExtension) {\n    super(url, 'internet');\n\n    const fileExtensionMatch = url.match(/^https?:\\/\\/.*\\/.*\\.(\\w*)\\?.*$/)\n      || url.match(/^https?:\\/\\/.*\\/.*\\.(\\w*)$/);\n\n    this.fileExtension = fileExtension || (fileExtensionMatch && fileExtensionMatch[1]) || 'html';\n  }\n}\nexport default WebFileConnection;\n","import ConnectionBase from './connection-base';\nimport * as Utils from '../utils/utils';\n\nclass InlineData extends ConnectionBase {\n  /**\n   * Inline data representation. This is typically CSV formatted data.\n   * @public\n   * @param {string} data\n   * @constructor\n   */\n  constructor(data) {\n    super();\n\n    this.data = data;\n\n    this.fileExtension = 'txt';\n  }\n\n  /**\n   * Get the load script representation\n   * @public\n   * @returns {string}\n   */\n  getScript() {\n    return `INLINE \"\\n${Utils.escapeText(this.data)}\\n\"`;\n  }\n\n  /**\n   * Get lib statement but there are none for inline data\n   * @private\n   */\n  getLibStatement() {\n  }\n\n  /**\n   * Get the QAE connection object but there are none for inline data\n   * @private\n   */\n  getQixConnectionObject() {\n  }\n}\n\nexport default InlineData;\n","/**\n * Escape values containing delimiter\n * @private\n * @param {string} data\n * @param {string} delimiter\n * @returns {string}\n */\nfunction escapeValueContainingDelimiter(data, delimiter) {\n  if (data && typeof data === 'string' && (data.indexOf(delimiter) > -1 || data.indexOf('\\n') > -1)) {\n    return `\"${data.replace(/\"/g, '\"\"').replace(/\\n/g, ' ')}\"`;\n  }\n\n  return data;\n}\n\n/**\n * Convert array date to a string in a csv format\n * @private\n * @param {array} data\n * @returns {string}\n */\nexport function convert(data) {\n  if (data instanceof Array === false) {\n    data = [data];\n  }\n\n  let csv = '';\n  const delimiter = ',';\n\n  const headers = Object.keys(data[0]);\n\n  csv = `${csv + headers.map(header => escapeValueContainingDelimiter(header, delimiter))\n    .join(delimiter)}\\n`;\n\n  let fields = [];\n\n  for (let i = 0; i < data.length; i += 1) {\n    fields = [];\n\n    for (let j = 0; j < headers.length; j += 1) {\n      fields.push(escapeValueContainingDelimiter(data[i][headers[j]], delimiter));\n    }\n\n    csv = `${csv + fields.join(delimiter)}\\n`;\n  }\n\n  csv = csv.slice(0, -('\\n'.length));\n\n  return csv;\n}\n\n/**\n * Validate that the data is an JSON array\n * @private\n * @param {array} data\n * @returns {boolean}\n */\nexport function isJson(data) {\n  if (data instanceof Array) {\n    if (data[0] && typeof data[0] === 'object') {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import Connections from './connections';\nimport * as JsonToCsv from './utils/json-to-csv';\nimport ConnectionMatcher from './connection-matcher';\n\nconst connectionMatcher = new ConnectionMatcher();\n\n// url to a table file\nconnectionMatcher.addConnection(data => typeof data === 'string' && data.match(/^https?:\\/\\/(.*)$/g), data => new Connections.Web(data));\n\n// Path to a table file\nconnectionMatcher.addConnection(data => typeof data === 'string' && data.match(/^.*\\.(.*)$/g), data => new Connections.File(data));\n\n// Inline JSON table to csv\nconnectionMatcher.addConnection(\n  data => data instanceof Array && JsonToCsv.isJson(data),\n  data => new Connections.Inline(JsonToCsv.convert(data)),\n);\n\n// Inline csv table\nconnectionMatcher.addConnection(data => typeof data === 'string', data => new Connections.Inline(data));\n\nexport default connectionMatcher;\n","class ConnectionLookup {\n  /**\n   * Utility to add a matching function and a connection type to make it easier to implicitly choose a connection\n   * @private\n   * @constructor\n   */\n  constructor() {\n    this.connectionsRegistry = [];\n  }\n\n  /**\n   * Connection matching callback to identify which connection to use for an implicitly declared source.\n   * @callback connectionMatchingCallback\n   * @param {string} data - Url, file path, csv data\n   * @returns {Connection}\n   */\n\n  /**\n   * Add a matching function with a connection instance\n   * @private\n   * @param {connectionMatchingCallback} matchingFn - Matching function to decide what connection function to invoke\n   * @param {Connection} connection - Callback that returns a Connection instance\n   */\n  addConnection(matchingFn, connection) {\n    this.connectionsRegistry.push({\n      matchingFn,\n      connection,\n    });\n  }\n\n  /**\n   * Find a match for connection based on the input data\n   * @private\n   * @param {string} data - The data can be an Url, a file path or a csv data blob\n   * @returns {object}\n   */\n  findMatch(data) {\n    for (let i = 0; i < this.connectionsRegistry.length; i += 1) {\n      if (this.connectionsRegistry[i].matchingFn(data)) {\n        return this.connectionsRegistry[i].connection(data);\n      }\n    }\n\n    return data;\n  }\n}\n\nexport default ConnectionLookup;\n","import { escapeText } from './utils';\n\n/**\n * Validates supported character sets\n * @private\n * @param {string} characterSet\n * @returns {boolean|string}\n */\nfunction supportedCharacterSet(characterSet) {\n  const validCharacterSets = ['utf8', 'unicode', 'ansi', 'oem', 'mac'];\n\n  return (validCharacterSets.indexOf(characterSet) > -1 && characterSet)\n    || (Number(characterSet).toString() !== 'NaN' && `codepage is ${characterSet}`);\n}\n\n/**\n * Get the QIX specific format of a file\n * @private\n * @param {{ fileExtension: string, headerRowNr: number, delimiter: string, characterSet: string, srcTable: string, noLabels: boolean }} options\n * @returns {string}\n */\nexport default function formatSpecification(options) {\n  if (!options) {\n    options = {};\n  }\n\n  const formatSpecificationArr = [];\n\n  if (options.fileExtension) {\n    let fileFormat = options.fileExtension;\n\n    if (fileFormat === 'xlsx') {\n      fileFormat = 'ooxml';\n    }\n\n    if (fileFormat === 'csv') {\n      fileFormat = 'txt';\n    }\n\n    if (fileFormat === 'htm') {\n      fileFormat = 'html';\n    }\n\n    formatSpecificationArr.push(fileFormat);\n  }\n\n  if (options.headerRowNr || options.headerRowNr === 0) {\n    formatSpecificationArr.push(`header is ${options.headerRowNr} lines`);\n    // Should be included if header row is specified!\n    formatSpecificationArr.push('embedded labels');\n  }\n\n  if (options.delimiter) {\n    formatSpecificationArr.push(`delimiter is '${options.delimiter}'`);\n  }\n\n  if (options.characterSet && supportedCharacterSet(options.characterSet)) {\n    formatSpecificationArr.push(supportedCharacterSet(options.characterSet));\n  }\n\n  if (options.srcTable) {\n    formatSpecificationArr.push(`table is \"${escapeText(options.srcTable)}\"`);\n  }\n\n  if (options.noLabels) {\n    formatSpecificationArr.push('no labels');\n  }\n\n  let formatSpecificationString = '';\n\n  if (formatSpecificationArr.length > 0) {\n    formatSpecificationString = `\\n(${formatSpecificationArr.join(', ')})`;\n  }\n\n  return formatSpecificationString;\n}\n","import defaultConnectionMatcher from './default-connection-matcher';\nimport formatSpecification from './utils/format-specification';\nimport { escapeText, validFieldType, indentation } from './utils/utils';\n\nclass Table {\n  /**\n   * Table definition\n   * @public\n   * @class\n   * @param {Connection} connection\n   * @param {object} options - Table options\n   * @param {string} options.name - Table name\n   * @param {Field[]} options.fields - Array of field objects\n   * @param {string} options.prefix - Add prefix before the table\n   * @param {string} options.section - Section to add table to\n   * @constructor\n   */\n  constructor(connection, options) {\n    this.connection = defaultConnectionMatcher.findMatch(connection);\n\n    options = options || {};\n\n    if (typeof options === 'string') {\n      this.name = options;\n      options = {};\n    } else {\n      this.name = options.name;\n      this.fields = options.fields;\n      this.prefix = options.prefix;\n      if (options.section) {\n        this.section = options.section;\n      }\n    }\n\n    this.options = options;\n  }\n\n  /**\n   * @typedef {object} Field\n   * @public\n   * @property {string} src - Name in the data source of the field\n   * @property {string} name - Name after reload\n   * @property {string} type - Date, Time, TimeStamp\n   * @property {string} inputFormat - Input format to explain how a field should be parsed.\n   * @property {string} displayFormat - Display format that should be used after reload.\n   * @property {string} expr - Customize how this field should be loaded with Qlik Script.\n   */\n\n  /**\n   * Get the fields from a table\n   * @public\n   * @returns {Field[]} Array of fields\n   */\n  getFields() {\n    return this.fields;\n  }\n\n  /**\n   * Get the script representation of the field list. If nothing is specified than all the fields will be returned.\n   * @public\n   * @returns {string}\n   */\n  getFieldList() {\n    if (this.fields) {\n      return this.fields.map((field) => {\n        let formattedInput = `\"${escapeText(field.src || '')}\"`;\n\n        if (validFieldType(field.type)) {\n          const format = field.type.toUpperCase();\n\n          if (field.inputFormat) {\n            formattedInput = `${format}#(${formattedInput}, '${field.inputFormat}')`;\n          }\n\n          if (field.displayFormat) {\n            formattedInput = `${format}(${formattedInput}, '${field.displayFormat}')`;\n          } else {\n            formattedInput = `${format}(${formattedInput})`;\n          }\n        }\n\n        if (field.expr) {\n          formattedInput = field.expr;\n        }\n\n\n        if (!(field.name || field.src)) {\n          throw (new Error(`A name or src needs to specified on the field: ${JSON.stringify(field)}`));\n        }\n\n        return `${indentation() + formattedInput} AS \"${escapeText(field.name || field.src)}\"`;\n      }).join(',\\n');\n    }\n\n    return '*';\n  }\n\n  /**\n   * Is the table used as a proceeding load\n   * @public\n   * @returns {boolean}\n   */\n  isProceedingLoad() {\n    return this.connection instanceof Table;\n  }\n\n  /**\n   * Returns the specified prefix of the table if it exists.\n   * The prefix can be for instance be a Qlik script snippet that always should be executed before the table is loaded.\n   * @public\n   * @returns {string}\n   */\n  getPrefix() {\n    if (this.prefix) {\n      return `${this.prefix}\\n`;\n    }\n    return '';\n  }\n\n  /**\n   * Get the script representation of the table\n   * @public\n   * @returns {string}\n   */\n  getScript() {\n    // In the future this could be moved into a connectionMatcher\n    // but for sake of clarity it is kept inline.\n    if (this.isProceedingLoad()) {\n      return `${this.getPrefix()}LOAD\\n${this.getFieldList()};\\n${this.connection.getScript()}`;\n    }\n\n    // Hack!\n    if (this.connection.getFileExtension) {\n      this.options.fileExtension = this.connection.getFileExtension();\n    }\n\n    return `${this.getPrefix()}LOAD\\n${this.getFieldList()}\\n${this.connection.getScript()}${formatSpecification(this.options)};`;\n  }\n\n  /**\n   * Get the name of the table\n   * @public\n   * @returns {string}\n   */\n  getName() {\n    return this.name || '';\n  }\n\n  /**\n   * Get the section that the table belongs to\n   * @public\n   * @returns {string}\n   */\n  getSection() {\n    return this.section;\n  }\n\n  /**\n   * Returns the connection or table that the table uses.\n   * @public\n   * @returns {(Connection|Table)} Connection or Table\n   */\n  getConnection() {\n    return this.connection;\n  }\n}\n\nexport default Table;\n","/**\n * @constant\n * @type {{timestamp: string, date: string, time: string, interval: string}}\n */\nconst qTypes = {\n  timestamp: 'TS',\n  date: 'D',\n  time: 'T',\n  interval: 'IV',\n};\n\n/**\n * @constant\n * @type {{timestamp: string, text: string, numeric: string}}\n */\nconst qDimensionType = {\n  timestamp: 'T',\n  text: 'D',\n  numeric: 'N',\n};\n\nexport default {\n  qTypes,\n  qDimensionType,\n};\n","import hyperCubeSpecification from './hyper-cube-specification';\n\nconst DEFAULT_DELIMITER = ',';\n\n/**\n * If a dimension has mixed types\n * @private\n * @param {QAE.NxDimension} dimension\n * @returns {boolean}\n */\nfunction isDimensionTypeMixed(dimension) {\n  return (\n    dimension.qDimensionType === hyperCubeSpecification.qDimensionType.numeric\n    && dimension.qTags.length === 0\n  );\n}\n\n/**\n * Is dimension type a text\n * @private\n * @param {QAE.NxDimension} dimension\n * @returns {boolean}\n */\nfunction isDimensionTypeText(dimension) {\n  return dimension.qDimensionType === hyperCubeSpecification.qDimensionType.text;\n}\n\n/**\n * Is dimension type a timestamp\n * @private\n * @param {QAE.NxDimension} dimension\n * @returns {boolean}\n */\nfunction isDimensionTypeTimestamp(dimension) {\n  if (dimension.qDimensionType === hyperCubeSpecification.qDimensionType.timestamp) {\n    return true;\n  }\n  if (\n    dimension.qDimensionType === hyperCubeSpecification.qDimensionType.numeric\n    && dimension.qNumFormat.qType === hyperCubeSpecification.qTypes.timestamp\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Is dimension type a date\n * @private\n * @param {QAE.NxDimension} dimension\n * @returns {boolean}\n */\nfunction isDimensionTypeDate(dimension) {\n  if (\n    dimension.qDimensionType === hyperCubeSpecification.qDimensionType.numeric\n    && dimension.qNumFormat.qType === hyperCubeSpecification.qTypes.date\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Is dimension type a time\n * @private\n * @param {QAE.NxDimension} dimension\n * @returns {boolean}\n */\nfunction isDimensionTypeTime(dimension) {\n  if (\n    dimension.qDimensionType === hyperCubeSpecification.qDimensionType.numeric\n    && dimension.qNumFormat.qType === hyperCubeSpecification.qTypes.time\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Is dimension type an interval\n * @private\n * @param {QAE.NxDimension} dimension\n * @returns {boolean}\n */\nfunction isDimensionTypeInterval(dimension) {\n  if (\n    dimension.qDimensionType === hyperCubeSpecification.qDimensionType.numeric\n    && dimension.qNumFormat.qType === hyperCubeSpecification.qTypes.interval\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Get dimension type where the dimension matches one of the following text, mixed, timestamp, time, data, interval or num.\n * @private\n * @param {QAE.NxDimension} dimension\n * @returns {string}\n */\nexport function getDimensionType(dimension) {\n  if (isDimensionTypeText(dimension)) {\n    return 'text';\n  }\n  if (isDimensionTypeMixed(dimension)) {\n    return 'mixed';\n  }\n  if (isDimensionTypeTimestamp(dimension)) {\n    return 'timestamp';\n  }\n  if (isDimensionTypeTime(dimension)) {\n    return 'time';\n  }\n  if (isDimensionTypeDate(dimension)) {\n    return 'date';\n  }\n  if (isDimensionTypeInterval(dimension)) {\n    return 'interval';\n  }\n  return 'num';\n}\n\n/**\n * Is numeric dimension type\n * @private\n * @param {string} dimensionType\n * @returns {boolean}\n */\nfunction isNumericDimensionType(dimensionType) {\n  const numericDimensionTypes = [\n    'timestamp',\n    'interval',\n    'time',\n    'date',\n    'num',\n  ];\n  dimensionType = dimensionType || '';\n  return numericDimensionTypes.indexOf(dimensionType.toLowerCase()) > -1;\n}\n\n/**\n * Is field numeric\n * @private\n * @param {QAE.NxField} field\n * @returns {boolean}\n */\nfunction storeNumeric(field) {\n  if (field.type === 'measure') {\n    return true;\n  }\n  if (\n    field.type === 'dimension' && isNumericDimensionType(field.dimensionType)\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Check if field is a dual value\n * @private\n * @param {Field} field\n * @returns {boolean}\n */\nexport function checkIfFieldIsDual(field) {\n  return field.type === 'dimension' && field.dimensionType === 'num';\n}\n\n/**\n * Has cell a dual value\n * @private\n * @param {QAE.NxCell} cell\n * @param {Field} field\n * @returns {boolean}\n */\nexport function isCellDual(cell, field) {\n  return checkIfFieldIsDual(field) && cell.qText !== Number(cell.qNum).toString();\n}\n\n/**\n * Escape string containing delimiter\n * @private\n * @param {string} string\n * @param {string} delimiter\n * @returns {string}\n */\nfunction escapeStringContainingDelimiter(string, delimiter) {\n  if (string.indexOf(delimiter) > -1 || string.indexOf('\\n') > -1) {\n    return `'${string.replace(/'/g, \"''\").replace(/\\n/g, ' ')}'`;\n  }\n  return string;\n}\n\n/**\n * Get the numeric from cell value\n * @private\n * @param {QAE.NxCell} cell\n * @returns {number}\n */\nfunction getNumericCellValue(cell) {\n  return cell.qNum;\n}\n\n/**\n * Get the text from a cell value\n * @private\n * @param {QAE.NxCell} cell\n * @returns {string}\n */\nfunction getTextCellValue(cell) {\n  return escapeStringContainingDelimiter(cell.qText, DEFAULT_DELIMITER);\n}\n\n/**\n * Get the value of a cell\n * @private\n * @param {QAE.NxCell} cell\n * @param {Field} field\n * @returns {(string|number)}\n */\nexport function getCellValue(cell, field) {\n  if (storeNumeric(field)) {\n    return getNumericCellValue(cell);\n  }\n  return getTextCellValue(cell);\n}\n\n/**\n * Get dual data row\n * @private\n * @param {QAE.NxCell} cell\n * @returns {string}\n */\nexport function getDualDataRow(cell) {\n  return `${cell.qNum}${DEFAULT_DELIMITER}${escapeStringContainingDelimiter(cell.qText, DEFAULT_DELIMITER)}`;\n}\n\n/**\n * Get dual headers from a field\n * @private\n * @param {Field} field\n * @returns {string}\n */\nexport function getDualHeadersForField(field) {\n  return `${field.name}${DEFAULT_DELIMITER}${field.name}_qText}`;\n}\n","import Table from './table';\nimport { validFieldType } from './utils/utils';\nimport * as HyperCubeUtils from './utils/hyper-cube-utils';\n\nclass HyperCube {\n  /**\n   * Hypercube representation\n   * @public\n   * @class\n   * @param {object} hyperCubeLayout - The QIX representation of a hypercube\n   * @param {object} options - Hypercube options\n   * @param {string} name - Name\n   * @param {string} section - Section to add hypercube data to\n   * @constructor\n   */\n  constructor(hyperCubeLayout, options) {\n    this.items = [];\n    this.fields = [];\n    this.hyperCubeLayout = this.validateHyperCubeLayout(hyperCubeLayout);\n\n    options = options || {};\n\n    if (typeof options === 'string') {\n      this.name = options;\n      options = {};\n    } else {\n      this.name = options.name;\n      if (options.section) {\n        this.section = options.section;\n      }\n    }\n\n    this.parseHyperCubeLayout(options);\n\n    this.options = options;\n  }\n\n  /**\n   * Validate the hypercube layout\n   * @private\n   * @param {object} hyperCubeLayout\n   * @returns {object} hyperCubeLayout\n   */\n  validateHyperCubeLayout(hyperCubeLayout) {\n    if (!hyperCubeLayout) { throw new Error('Hyper cube layout is undefined'); }\n    if (!hyperCubeLayout.qDimensionInfo) { throw new Error('qDimensionInfo is undefined'); }\n    if (!hyperCubeLayout.qMeasureInfo) { throw new Error('qMeasureInfo is undefined'); }\n    if (hyperCubeLayout.qMode === 'P') { throw new Error('Cannot add hyper cube in pivot mode, qMode:P(DATA_MODE_PIVOT) is not supported'); }\n    if (hyperCubeLayout.qMode === 'K') { throw new Error('Cannot add hyper cube in stacked mode, qMode:K(DATA_MODE_PIVOT_STACK) is not supported'); }\n    if (hyperCubeLayout.qMode === 'S') {\n      this.validateDataPages(hyperCubeLayout.qDataPages);\n      this.validateDataPagesCoverage(hyperCubeLayout.qDataPages, hyperCubeLayout);\n      return hyperCubeLayout;\n    }\n    throw new Error('HyperCubeLayout is not valid');\n  }\n\n  /**\n   * Validates the datapages of the hypercube\n   * @private\n   * @param {object} dataPages\n   */\n  validateDataPages(dataPages) {\n    if (!dataPages) {\n      throw new Error('qDataPages are undefined');\n    }\n\n    if (dataPages[0].qArea && dataPages[0].qArea.qTop > 0) {\n      throw new Error('qDataPages first page should start at qTop: 0.');\n    }\n  }\n\n  /**\n   * Validates that all datapages in the hypercube is covered\n   * @private\n   * @param {object[]} dataPages\n   * @param {object} hyperCubeLayout\n   */\n  validateDataPagesCoverage(dataPages, hyperCubeLayout) {\n    let qHeight = 0;\n\n    dataPages.forEach((dataPage) => {\n      this.validateQMatrix(dataPage);\n      this.validateQArea(dataPage, hyperCubeLayout, qHeight);\n      qHeight += dataPage.qArea.qHeight;\n    }, this);\n\n    if (hyperCubeLayout.qSize.qcy !== qHeight) {\n      throw new Error('qDataPages are missing pages.');\n    }\n  }\n\n  /**\n   * Validates the QMatrix in the datapage\n   * @private\n   * @param {object} dataPage\n   */\n  validateQMatrix(dataPage) {\n    if (!dataPage.qMatrix) {\n      throw new Error('qMatrix of qDataPages are undefined');\n    }\n    if (dataPage.qMatrix.length === 0) {\n      throw new Error('qDataPages are empty');\n    }\n  }\n\n  /**\n   * Validates the QArea in the datapage\n   * @private\n   * @param {object} dataPage\n   * @param {object} hyperCubeLayout\n   * @param {number} qHeight\n   */\n  validateQArea(dataPage, hyperCubeLayout, qHeight) {\n    if (!dataPage.qArea) {\n      throw new Error('qArea of qDataPages are undefined');\n    }\n    if (dataPage.qArea.qLeft > 0) {\n      throw new Error('qDataPages have data pages that\\'s not of full qWidth.');\n    }\n    if (dataPage.qArea.qWidth < hyperCubeLayout.qSize.qcx) {\n      throw new Error('qDataPages have data pages that\\'s not of full qWidth.');\n    }\n    if (dataPage.qArea.qTop < qHeight) {\n      throw new Error('qDataPages have overlapping data pages.');\n    }\n    if (dataPage.qArea.qTop > qHeight) {\n      throw new Error('qDataPages are missing pages.');\n    }\n  }\n\n  /**\n   * Parses the hypercube an extracts the data\n   * @private\n   */\n  parseHyperCubeLayout() {\n    const that = this;\n    that.fields = that.getFieldsFromHyperCubeLayout();\n    that.data = that.getDataFromHyperCubeLayout();\n    const inlineData = `${that.fields\n      .map(field => field.name)\n      .join(',')}\\n${this.data}`;\n    let hasDual = false;\n    that.fields.forEach((field) => {\n      if (field.isDual) {\n        hasDual = true;\n        that.items.push(that.getMapTableForDualField(field));\n      }\n    });\n    const options = {\n      name: that.name,\n      fields: that.getFieldsDefinition(that.fields),\n    };\n    if (that.section && !hasDual) {\n      options.section = that.section;\n    }\n    that.items.push(new Table(inlineData, options));\n  }\n\n  /**\n   * Get the Fields definition\n   * @private\n   * @param {object[]} fields\n   * @returns {object[]} fields\n   */\n  getFieldsDefinition(fields) {\n    return fields.map((field) => {\n      const mappedField = { name: field.name };\n      if (validFieldType(field.dimensionType)) {\n        mappedField.type = field.dimensionType;\n        mappedField.displayFormat = field.displayFormat;\n      }\n      if (field.isDual) {\n        mappedField.expr = `Dual(ApplyMap('MapDual__${field.name}', \"${field.name}\"), \"${field.name}\")`;\n      } else {\n        mappedField.src = field.name;\n      }\n      return mappedField;\n    });\n  }\n\n  /**\n   * Return qmatrix with dual fields\n   * @private\n   * @param {object} qMatrix\n   * @param {object} field\n   * @returns {object} field\n   */\n  mapDualFieldQMatrix(qMatrix, field) {\n    function uniqueFilter(value, index, self) {\n      return self.indexOf(value) === index;\n    }\n    return qMatrix\n      .map(row => HyperCubeUtils.getDualDataRow(row[field.index]))\n      .filter(uniqueFilter);\n  }\n\n  /**\n   * Get table with dual fields\n   * @private\n   * @param {object} field\n   * @returns {object} Table\n   */\n  getMapTableForDualField(field) {\n    const that = this;\n    const concatQMatrix = that.hyperCubeLayout.qDataPages.reduce(\n      (prev, curr) => [...prev, ...curr.qMatrix],\n      [],\n    );\n    const data = that.mapDualFieldQMatrix(concatQMatrix, field);\n    const headers = HyperCubeUtils.getDualHeadersForField(field);\n    const inlineData = `${headers}\\n${data.join('\\n')}`;\n    const name = `MapDual__${field.name}`;\n    const options = { name, prefix: 'Mapping' };\n    if (this.section && this.items.length === 0) {\n      options.section = this.section;\n    }\n    return new Table(inlineData, options);\n  }\n\n  /**\n   * Extracts the data from the hypercube layout as a csv representation\n   * @private\n   * @returns {string}\n   */\n  getDataFromHyperCubeLayout() {\n    const that = this;\n    const data = that.hyperCubeLayout.qDataPages\n      .map(dataPage => dataPage.qMatrix\n        .map(row => row\n          .map((cell, index) => {\n            const field = that.fields[index];\n            if (!field.isDual && HyperCubeUtils.isCellDual(cell, field)) {\n              field.isDual = true;\n            }\n            return HyperCubeUtils.getCellValue(cell, field);\n          })\n          .join(','))\n        .join('\\n'))\n      .join('\\n');\n    return data;\n  }\n\n  /**\n   * Get the fields from the hypercube\n   * @private\n   * @returns {Array<{type: string, dimensionType: string, name: string, displayFormat: string, index: number}>} - An array of dimension and measures\n   */\n  getFieldsFromHyperCubeLayout() {\n    const that = this;\n    const fields = [];\n    for (let i = 0; i < that.hyperCubeLayout.qDimensionInfo.length; i += 1) {\n      fields.push({\n        type: 'dimension',\n        dimensionType: HyperCubeUtils.getDimensionType(that.hyperCubeLayout.qDimensionInfo[i]),\n        name: that.hyperCubeLayout.qDimensionInfo[i].qFallbackTitle,\n        displayFormat: that.hyperCubeLayout.qDimensionInfo[i].qNumFormat.qFmt,\n        index: i,\n      });\n    }\n    for (let j = 0; j < that.hyperCubeLayout.qMeasureInfo.length; j += 1) {\n      fields.push({\n        type: 'measure',\n        name: that.hyperCubeLayout.qMeasureInfo[j].qFallbackTitle,\n        index: that.hyperCubeLayout.qDimensionInfo.length + j,\n      });\n    }\n    return fields;\n  }\n\n  /**\n   * Get tables from the hypercube\n   * @public\n   * @returns {object[]} Tables\n   */\n  getItems() {\n    return this.items;\n  }\n}\n\nexport default HyperCube;\n","class SetStatement {\n  /**\n   * Define set statements\n   * @class\n   * @public\n   * @param {object} defaultSetStatements - A representation where each property name will be used as key and the property will be the value\n   * @constructor\n   */\n  constructor(defaultSetStatements) {\n    this.defaultSetStatements = defaultSetStatements;\n  }\n\n  /**\n   * Get the entire set statement as script\n   * @public\n   * @returns {string}\n   */\n  getScript() {\n    return Object.keys(this.defaultSetStatements)\n      .map(key => `SET ${key}='${Array.isArray(this.defaultSetStatements[key])\n        ? this.defaultSetStatements[key].join(';') : this.defaultSetStatements[key]}';`)\n      .join('\\n');\n  }\n\n  /**\n   * Always returns the name as empty\n   * @public\n   * @returns {string}\n   */\n  getName() {\n    return '';\n  }\n}\n\nexport default SetStatement;\n","import { getFieldName, escapeText } from './utils/utils';\n\nclass DerivedFieldsTemplate {\n  /**\n   * Declare fields that can be derived from a template. An example can be a calendar template.\n   * @public\n   * @param {object} options - Derived Field Template definition.\n   * @param {callback} options.fieldMatchFunction - Matching function that will apply a field template definition.\n   * @param {string} options.name - Name of derived field.\n   * @param {string} options.fieldTag - What field tag that will be used in the derived field.\n   * @param {string} options.derivedFieldDefinition - What script definition should be used in the derived field.\n   * @constructor\n   */\n  constructor(options) {\n    this.getFieldFn = options.fieldMatchFunction;\n    this.name = options.name;\n    this.fieldTag = options.fieldTag;\n    this.derivedFieldDefinition = options.derivedFieldDefinition;\n  }\n\n  /**\n   * Returns the script\n   * @public\n   * @returns {string}\n   */\n  getScript() {\n    const fields = this.getFieldFn() || [];\n\n    if (fields.length > 0) {\n      return this.getDefinition(fields.map(getFieldName));\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Get the script definition for a set of specific fields\n   * @public\n   * @param {string[]} fieldNames - An array of strings with field names.\n   * @returns {string}\n   */\n  getDefinition(fieldNames) {\n    return `\"${escapeText(this.name)}\":\nDECLARE FIELD DEFINITION Tagged ('$${this.fieldTag}')\nFIELDS\n${this.derivedFieldDefinition}\nDERIVE FIELDS FROM FIELDS [${fieldNames.join(', ')}] USING \"${escapeText(this.name)}\";`;\n  }\n}\n\nexport default DerivedFieldsTemplate;\n","import DerivedFieldTemplate from './derived-fields-template';\n\nconst derivedFieldsDefinition = `Dual(Year($1), YearStart($1)) AS [Year] Tagged ('$axis', '$year'),\n  Dual('Q'&Num(Ceil(Num(Month($1))/3)),Num(Ceil(NUM(Month($1))/3),00)) AS [Quarter] Tagged ('$quarter', '$cyclic'),\n  Dual(Year($1)&'-Q'&Num(Ceil(Num(Month($1))/3)),QuarterStart($1)) AS [YearQuarter] Tagged ('$yearquarter', '$qualified'),\n  Dual('Q'&Num(Ceil(Num(Month($1))/3)),QuarterStart($1)) AS [_YearQuarter] Tagged ('$yearquarter', '$hidden', '$simplified'),\n  Month($1) AS [Month] Tagged ('$month', '$cyclic'),\n  Dual(Year($1)&'-'&Month($1), monthstart($1)) AS [YearMonth] Tagged ('$axis', '$yearmonth', '$qualified'),\n  Dual(Month($1), monthstart($1)) AS [_YearMonth] Tagged ('$axis', '$yearmonth', '$simplified', '$hidden'),\n  Dual('W'&Num(Week($1),00), Num(Week($1),00)) AS [Week] Tagged ('$weeknumber', '$cyclic'),\n  Date(Floor($1)) AS [Date] Tagged ('$axis', '$date', '$qualified'),\n  Date(Floor($1), 'D') AS [_Date] Tagged ('$axis', '$date', '$hidden', '$simplified'),\n  If (DayNumberOfYear($1) <= DayNumberOfYear(Today()), 1, 0) AS [InYTD] ,\nYear(Today())-Year($1) AS [YearsAgo] ,\n  If (DayNumberOfQuarter($1) <= DayNumberOfQuarter(Today()),1,0) AS [InQTD] ,\n4*Year(Today())+Ceil(Month(Today())/3)-4*Year($1)-Ceil(Month($1)/3) AS [QuartersAgo] ,\nCeil(Month(Today())/3)-Ceil(Month($1)/3) AS [QuarterRelNo] ,\n  If(Day($1)<=Day(Today()),1,0) AS [InMTD] ,\n12*Year(Today())+Month(Today())-12*Year($1)-Month($1) AS [MonthsAgo] ,\nMonth(Today())-Month($1) AS [MonthRelNo] ,\n  If(WeekDay($1)<=WeekDay(Today()),1,0) AS [InWTD] ,\n(WeekStart(Today())-WeekStart($1))/7 AS [WeeksAgo] ,\nWeek(Today())-Week($1) AS [WeekRelNo];`;\n\n/**\n * A field matching callback to identify which fields that are associated with a specific calendarTemplate.\n * @callback fieldMatchingCalendarCallback\n * @param {string} calendarTemplate\n * @param {Field} field\n */\n\n/**\n * Get the derived field definition for a field that matches the pattern\n * @public\n * @param {fieldMatchingCalendarCallback} fn - Field matcher function\n * @returns {DerivedFieldsTemplate}\n */\nfunction getCalenderDerivedFieldDefinition(fn) {\n  return new DerivedFieldTemplate({\n    name: 'autoCalendar',\n    fieldTag: 'date',\n    derivedFieldDefinition: derivedFieldsDefinition,\n    fieldMatchFunction: () => fn(f => f.calendarTemplate),\n  });\n}\n\nexport default getCalenderDerivedFieldDefinition;\n","import Table from './table';\nimport HyperCube from './hyper-cube';\nimport Connections from './connections';\nimport SetStatement from './set-statement';\n\nimport * as Utils from './utils/utils';\nimport getDerivedFieldDefinition from './calendar-derived-fields';\n\nconst SCRIPT_BLOCK_SPACING = '\\n\\n';\n\nclass Halyard {\n  /**\n   * Representation of tables or hypercubes to load\n   * @class\n   * @public\n   * @constructor\n   */\n  constructor() {\n    this.defaultSetStatements = {};\n    this.items = [];\n    this.addItem(new SetStatement(this.defaultSetStatements));\n    this.lastItems = [getDerivedFieldDefinition(x => this.getFields(x))];\n  }\n\n  /**\n   * Get connections object that are used in the model\n   * @public\n   * @returns {Connection[]}\n   */\n  getConnections() {\n    return this.items.filter(item => item.getConnection).map(item => item.getConnection());\n  }\n\n  /**\n   * Get the QIX connections definitions that are used in the model\n   * @public\n   * @returns {{qName: (string), qConnectionString: (string), qType: (string)}\n   */\n  getQixConnections() {\n    return this.getConnections().map(connection => connection.getQixConnectionObject())\n      .filter(connection => connection);\n  }\n\n  /**\n   * Field matching callback to identify if a field matches another\n   * @callback fieldMatchingCallback\n   * @param {Field} field\n   * @returns {boolean}\n   */\n\n  /**\n   * Get fields that matches pattern sent in as params\n   * @public\n   * @param {fieldMatchingCallback} matcherFn\n   * @returns {Field[]}\n   */\n  getFields(matcherFn) {\n    matcherFn = matcherFn || (() => true);\n\n    const fields = [];\n\n    this.items.forEach((item) => {\n      if (item.getFields && item.getFields()) {\n        fields.push(...item.getFields().filter(matcherFn));\n      }\n    });\n\n    return fields;\n  }\n\n  /**\n   * Configure the default set statements like time, date, currency formats\n   * @public\n   * @param {SetStatement} defaultSetStatements\n   * @param {boolean} preservePreviouslyEnteredValues\n   */\n  setDefaultSetStatements(defaultSetStatements, preservePreviouslyEnteredValues) {\n    const that = this;\n\n    Object.keys(defaultSetStatements).forEach((key) => {\n      if (!(preservePreviouslyEnteredValues && that.defaultSetStatements[key])) {\n        that.defaultSetStatements[key] = defaultSetStatements[key];\n      }\n    });\n  }\n\n  /**\n   * Get the script for a item (table, preceeding load)\n   * @public\n   * @param {(Table|HyperCube)} item\n   * @returns {string}\n   */\n  getItemScript(item) {\n    let itemScript = item.getScript();\n\n    if (item.getName && item.getName()) {\n      if (item.section) {\n        itemScript = `///$tab ${Utils.escapeText(item.section)}\\n\"${Utils.escapeText(item.getName())}\":\\n${itemScript}`;\n      } else {\n        itemScript = `\"${Utils.escapeText(item.getName())}\":\\n${itemScript}`;\n      }\n    }\n\n    return itemScript;\n  }\n\n  /**\n   * Fetch all script blocks\n   * @public\n   * @returns {string[]}\n   */\n  getAllScriptBlocks() {\n    return this.items.concat(this.lastItems).filter(item => item.getScript());\n  }\n\n  /**\n   * Fetches the entire script\n   * @public\n   * @returns {string}\n   */\n  getScript() {\n    return this.getAllScriptBlocks().map(item => this.getItemScript(item))\n      .join(SCRIPT_BLOCK_SPACING);\n  }\n\n  /**\n   * Add hyper cube explicit or implicitly\n   * @public\n   * @param {HyperCube} arg1 - Hypercube\n   * @param {object} options - Hypercube options\n   * @param {string} options.name - Name\n   * @param {string} options.section - Section to add hypercube data to\n   * @returns {object} Hypercube\n   */\n  addHyperCube(arg1, options) {\n    let newHyperCube;\n\n    if (arg1 instanceof HyperCube) {\n      newHyperCube = arg1;\n    } else {\n      newHyperCube = new HyperCube(arg1, options);\n    }\n\n    for (let i = 0; i < newHyperCube.items.length; i += 1) {\n      this.checkIfItemNameExists(newHyperCube.items[i]);\n    }\n\n    for (let i = 0; i < newHyperCube.items.length; i += 1) {\n      this.addItem(newHyperCube.items[i]);\n    }\n\n    return newHyperCube;\n  }\n\n  /**\n   * Support to add table explicit or implicitly\n   * @public\n   * @param {Table} arg1 - Table\n   * @param {object} options\n   * @param {string} options.name - Table name\n   * @param {Field[]} options.fields - Array of field objects\n   * @param {string} options.prefix - Add prefix before the table\n   * @param {string} options.section - Section to add table to\n   * @returns {object} Table\n   */\n  addTable(arg1, options) {\n    let newTable;\n\n    if (arg1 instanceof Table) {\n      newTable = arg1;\n    } else {\n      newTable = new Table(arg1, options);\n    }\n\n    return this.addItem(newTable);\n  }\n\n  /**\n   * Verify that item doesn't exist in model\n   * @public\n   * @param {(Table|HyperCube)} newItem - Table or Hypercube\n   */\n  checkIfItemNameExists(newItem) {\n    if (newItem.getName && newItem.getName()) {\n      if (this.items.filter(item => item.getName() === newItem.getName()).length > 0) {\n        throw new Error('Cannot add another table with the same name.');\n      }\n    }\n  }\n\n  /**\n   * Add new item to the model\n   * @public\n   * @param {(Table|HyperCube)} newItem - Table or Hypercube\n   * @returns {(Table|HyperCube)} - Table or Hypercube\n   */\n  addItem(newItem) {\n    this.checkIfItemNameExists(newItem);\n\n    this.items.push(newItem);\n\n    return newItem;\n  }\n\n  /**\n   * Locate which item that generated a script at the specified character position\n   * @public\n   * @param {number} charPosition\n   * @returns {(Table|HyperCube)} - Table or Hypercube\n   */\n  getItemThatGeneratedScriptAt(charPosition) {\n    const allScriptBlocks = this.getAllScriptBlocks();\n    let scriptBlockStartPosition = 0;\n\n    for (let i = 0; i < allScriptBlocks.length; i += 1) {\n      const itemScript = this.getItemScript(allScriptBlocks[i]);\n      const scriptBlockEndPosition = scriptBlockStartPosition\n          + (`${itemScript}${SCRIPT_BLOCK_SPACING}`).length;\n\n      if (scriptBlockStartPosition <= charPosition && charPosition <= scriptBlockEndPosition) {\n        return allScriptBlocks[i];\n      }\n\n      scriptBlockStartPosition = scriptBlockEndPosition;\n    }\n\n    return undefined;\n  }\n}\n\nHalyard.Table = Table;\n\nHalyard.HyperCube = HyperCube;\n\nHalyard.Connections = Connections;\n\nexport default Halyard;\n\nif (typeof module !== 'undefined') {\n  module.exports = Halyard;\n}\n"],"names":["escapeText","text","replace","validFieldType","type","indexOf","toLowerCase","getFieldName","field","name","src","ConnectionBase","path","connectionType","fileExtension","this","qName","getName","qConnectionString","qType","getConnectionType","c","r","Math","random","toString","getLibStatement","File","folderPathMatch","fileNameMatch","fileExtensionMatch","match","fileName","Web","url","Inline","data","Utils","escapeValueContainingDelimiter","delimiter","connectionMatcher","connectionsRegistry","matchingFn","connection","push","i","length","supportedCharacterSet","characterSet","Number","addConnection","Connections","Array","_typeof","csv","headers","Object","keys","map","header","join","fields","j","slice","JsonToCsv","Table","options","defaultConnectionMatcher","findMatch","prefix","section","formattedInput","format","toUpperCase","inputFormat","displayFormat","expr","Error","JSON","stringify","isProceedingLoad","getPrefix","getFieldList","getScript","getFileExtension","formatSpecificationArr","fileFormat","headerRowNr","srcTable","noLabels","formatSpecificationString","formatSpecification","qTypes","timestamp","date","time","interval","qDimensionType","numeric","DEFAULT_DELIMITER","getDimensionType","dimension","hyperCubeSpecification","qTags","qNumFormat","escapeStringContainingDelimiter","string","getCellValue","cell","dimensionType","qNum","qText","HyperCube","hyperCubeLayout","items","validateHyperCubeLayout","parseHyperCubeLayout","qDimensionInfo","qMeasureInfo","qMode","validateDataPages","qDataPages","validateDataPagesCoverage","dataPages","qArea","qTop","qHeight","forEach","dataPage","_this","validateQMatrix","validateQArea","qSize","qcy","qMatrix","qLeft","qWidth","qcx","that","getFieldsFromHyperCubeLayout","getDataFromHyperCubeLayout","inlineData","hasDual","isDual","getMapTableForDualField","getFieldsDefinition","mappedField","row","index","filter","value","self","concatQMatrix","reduce","prev","curr","mapDualFieldQMatrix","HyperCubeUtils","qFallbackTitle","qFmt","SetStatement","defaultSetStatements","key","isArray","DerivedFieldsTemplate","getFieldFn","fieldMatchFunction","fieldTag","derivedFieldDefinition","getDefinition","fieldNames","derivedFieldsDefinition","Halyard","fn","addItem","lastItems","x","getFields","DerivedFieldTemplate","f","calendarTemplate","item","getConnection","getConnections","getQixConnectionObject","matcherFn","preservePreviouslyEnteredValues","itemScript","concat","getAllScriptBlocks","_this2","getItemScript","arg1","newHyperCube","checkIfItemNameExists","newTable","newItem","charPosition","allScriptBlocks","scriptBlockStartPosition","scriptBlockEndPosition","module","exports"],"mappings":"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"}